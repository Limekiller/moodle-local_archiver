<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

namespace local_archiver;

/**
 * Google OAuth manager
 *
 * @package     local_archiver
 * @copyright   2022 Bryce Yoder
 * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die;

require "$CFG->libdir/google/src/Google/autoload.php";

class google_oauth_manager {

    /**
     * Generate a Google OAuth client object
     * @param string optional $code An auth code generated by the OAuth flow
     * @param bool optional $fail_on_error Whether or not the method should throw an exception if the access token is invalid
     */
    public static function get_client($code='', $fail_on_error=true) {
        global $DB;
        global $CFG;

        $client = new \Google_Client();
        $client->setClientId(get_config('local_archiver', 'googleoauthclientid'));
        $client->setClientSecret(get_config('local_archiver', 'googleoauthclientsecret'));
        $redirect = filter_var("$CFG->wwwroot/local/archiver/oauth.php", FILTER_SANITIZE_URL);
        $client->setRedirectUri($redirect);
        $client->setScopes(array('https://www.googleapis.com/auth/drive'));

        $access_token = self::fetch_access_token();
        if ($access_token) {
            $client->setAccessToken($access_token);
        }

        if ($code) {
            $access_token = $client->fetchAccessTokenWithAuthCode($code);
            $client->setAccessToken($access_token);
            // Check to see if there was an error.
            if (array_key_exists('error', $access_token)) {
                throw new Exception(join(', ', $access_token));
            }
            self::save_access_token($access_token);
        }
    
        // If there is no previous token or it's expired.
        if ($client->isAccessTokenExpired()) {
            // Refresh the token if possible, else fetch a new one.
            if ($client->getRefreshToken()) {
                $client->fetchAccessTokenWithRefreshToken($client->getRefreshToken());
            } else {
                if ($fail_on_error) {
                    throw new \Exception(get_string('googleoautherror', 'local_archiver'));
                }
                // Request authorization from the user.
                $authUrl = $client->createAuthUrl();
                header("Location: $authUrl");
                die(); 
            }
        }

        return $client;
    }    

    /**
     * Fetch the access token or its row ID
     * @param bool $id Whether or not to fetch the ID of the row in the config_plugins table instead
     * @param bool $vanity Whether to retrieve the actual token or the vanity token
     * @return string|int The access token or its row ID
     */
    public static function fetch_access_token($id=false) {
        global $DB;

        $field = $id ? 'id' : 'value';
        $access_token = $DB->get_record(
            'config_plugins', 
            ['plugin' => 'local_archiver', 'name' => 'googleoauthaccesstoken'], 
            $fields=$field, 
            $strictness=IGNORE_MISSING
        );
        return $access_token->$field;
    }

    private static function save_access_token($token) {
        global $DB;

        $record_id = self::fetch_access_token($id=true);
        $record = new \stdclass;
        $record->id = $record_id;
        $record->value = json_encode($token);

        $DB->update_record('config_plugins', $record);
    }

}